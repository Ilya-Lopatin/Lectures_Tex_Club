\section{Введение в Unix системы}

\subsection{Пользовательская сессия}

\begin{Def}
	\underline{Пользователь} --- это некоторое целое число, UID. У него даже может не быть имени.
\end{Def}

Пользователи могут обьединяться в \textbf{группы}. Причем один пользователь может быть в нескольких группах. Группы нужны, чтобы организовывать совместный доступ к файлам и другим ресурсам.

Авторизация пользователя:
\begin{itemize}
	\item Текстовый вход (TTY console)
    \item Графический вход (sddm, kdm, gdm)
    \item Удаленное подключение (ssh, telnet)
\end{itemize}


Расширить права введением пароля:
\begin{itemize}
	\item su и sudo
	\item графические настройки
\end{itemize}


\subsection{Подключаемые модули аунтефикации (PAM)}

\begin{Def}
	\underline{PAM} - это набор библиотек, которые предоставляют API для авторизации пользователя и
	проверки прав.
\end{Def}


Способы авторизации:
\begin{itemize}
	\item \textbf{/etc/passwd \& /etc/shadow/}
	
	Информацию о пользователях можно найти в файле \textbf{/etc/passwd}. Там для каждого пользователя
	указаны имя пользователя, UID, группы пользователей, полное имя, путь до домашнего каталога и используемый интерпретатор.
	
	\textbf{Некоторые пользователи впринципе не могут войти в систему.} /sbin/nologin - тот shell, который сразу после входа моментально разлогонивает пользователя. Это нужно для того, чтобы иметь виртуальных пользователей. То есть преднозначенных для выполнения ровно одного процесса.
	
	Пароли хранятся в файле \textbf{/etc/shadow/} хешированном виде.
	
	\item \textbf{Биометрия} \\
	\textbf{Возможена авторизация не только по паролю.} Можно также, например, по отпечатку пальца 
	или по инфракрасной камере. Хотя многие бытовые ноутбуки последних годов выпуска не
	имеют драйверов под Linux, поэтому с этим возникают проблемы.
	
	\item \textbf{LDAP сервис} \\
	Если есть большое количество компьтерных организаций, то удобно \textbf{хранить все данные о пользователях централизованно}. В Unix системах для этого используется \textbf{LDAP сервис}.
\end{itemize}


\subsection{Создание пользователей}

Конечно, в графическом режиме можно зайти в настройки и нажать кнопочку добавить пользователя. Но как это сделать, если мы находимся на удаленном сервере?

Инструменты для создания пользователей:
\begin{itemize}
	\item \textbf{useradd} - стандартная Linux команда. Ей достаточно передать параметры пользователя.
	\item \textbf{adduser} - интерактивный инструмент командной строки. Shell скрипт, которым позволяет сделать useradd в интерактивном режиме.
\end{itemize}

Параметры создания пользователя:
\begin{itemize}
	\item Имя, группы, пароль, shell
	\item Изначальный контент домашней директории (обычно копируется из /etc/skel)
\end{itemize}

В /etc/skel в основном хранятся настройки пользователя:
\begin{itemize}
	\item \textbf{.profile} - настройки отдельного пользователя, включая переменные окружения
	\item \textbf{.bashrc} - настройки командного интерпретатора bash.
\end{itemize}

\subsection{Пользователь залогинился. Что дальше?}

У каждого пользователя есть свой shell. 

\begin{Def}
	\underline{Shell пользователя} --- это команда, которая исполняется при логине пользователя. Ее можно найти в /etc/passwd
\end{Def}

Shell программа инициализирует переменные окружения из ~/.profile и ~/.bashrc.

Общие для всех пользователей переменные могут быть указаны в /etc/profile и /etc/bashrc.

\subsection{\#!/bin/sh}

\begin{itemize}
	\item FreeBSD: самодостаточный shell program
	\item Основной в Линукс: symlink to \textbf{bash}
	\item Debian: symlink to \textbf{dash}
	\item Alpine: symlink to \textbf{busybox}
	\item MaxOS X: symlink to \textbf{zsh}
\end{itemize}

\textbf{zsh} используется в MACOS с недавнего времени по лицензионным соображениям. 
Также его используют и некоторые пользователи Linux из \textbf{соображений безопасности}, поскольку поддерживает некоторую дополнительную функциональность. Например, запрет на принципы переноса строки при копировании. Это контролируется, чтобы случайно не выполнить потенциально опасную команду. 

\textbf{bash} наиболее распространенный. У него есть много модулей для автодополнения.

\textbf{busybox \& dash} более простые. 

Кстати, у busybox есть своя особенность. В Alpine Linux все стандартные линуксовые команды являются символическими ссылками на некоторый файл busybox размером 800КБ. 

\begin{Def}
	\underline{Busybox} --- это один большой бинарник, который в зависимости от именни программы, которую запускают, выполняет разную функциональность.
\end{Def}

В системе \textbf{Android}, которая является Linux, тоже используется \textbf{busybox}. Такой подход нужен, чтобы \textbf{уменьшить количество программ и сэкономить место на диске}. Многие программы имеют дублирующую функциональность (например, разбор аргументов командной строки), поэтому логично сделать одну большую программу, которая ведет себя по-разному в зависимости от того, с каким именем вызывается.

\subsection{Переменные окружения}

\textbf{PATH} - Тут прописано, \textbf{где можно искать файлы}, которые вы запускаете без указания полного пути (PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin) \\
\textbf{EDITOR} - \textbf{Редактор по умолчанию.} Например, он вызывается при git commit. (EDITOR=emacs) \\
\textbf{LANG} - нужна, чтобы понять, на каком языке реализовывать интерфейс пользователя. \\
\textbf{LC\_ALL} - описыет, какую локаль использовать. \\

\textbf{В чем принципиальное отличие между LANG и LC\_ALL}? \textbf{LANG} используется прикладными приложениями и \textbf{высокоуровневыми фреймворками} для того, чтобы понять, на каком языке отображать интерфейс. \textbf{LC\_ALL} используется \textbf{стандартной С библиотекой}. В частности, в функциях ввода/вывода, форматировании дат и т.д. То есть это более низкоуровневая вещь.

\textbf{Сокращения (Aliases)} \\
alias ..='cd ..' \\
alias ды='ls'


Если вы обьявили переменную, она существует в рамках того shell, который сейчас запущен. Как только shell завершит свою работу или запустит дочерние процесс, никому эти переменные не будут известны. Команда \textbf{export} говорит, что эта \textbf{переменная должна быть доступна всем дочерним процессам}, а не только в текущем сеансе. 


\subsection{Текстовые кодировки}

Есть два способа кодирования символов:
\begin{itemize}
	\item Использовать несколько байт на один символ (wchar\_t, std::wstring). 
	\item Последовательность байт (char, std::string).
\end{itemize}

\subsection{Пример: Русский язык}

\begin{itemize}
	\item ANSI (7 bits)  - только US/UK Английский язык
	\item KOI8-R and KOI8-U - один бит для переключения языка
	\item OEM Encoding - поддержка на уровне <<железа>>
	\item ANSI Encoding - все символы кириллицы от Microsoft.
\end{itemize}

\subsection{UTF-8}

\begin{Def}
	\underline{UTF-8} --- универсальный способ, который \textbf{покрывает все языки} и при этом является обратно совместимым с кодировкой ASCII. Сейчас стал стандартном как в интернете, так и в написании исходных текстов.
\end{Def} 

\textbf{В чем идея?}

Если старший бит равен 0, то младшие 7 бит в точности совпадают с кодом символов в кодировке ASCII.

Если есть символы, которые не покрываются ASCII, то они кодируются последовательностью байт, где в старших байтах каждый из байт - единица. 

Большинство европейских символов покрываются 2-мя байтами на один символ. Азиатские - 3 байта на символ. Смайлики, эмодзи - 4 байта на символ. 

\subsection{Вход пользователя}

\begin{itemize}
	\item Login + shell
	\item startx + xinitrc - что-то из 90-х ...
\end{itemize}

В современных системах, если это не серверная конфигурация, сразу запускается сеанс с графическим рабочим столом.

\textbf{Графическая сессия состоит из:}
\begin{itemize}
	\item \textbf{X11 сервер} - отвечает за \textbf{взаимодействие с видеокартой, клавиатурой} и всем остальным.
	\item \textbf{Менеджер дисплея} - отвечает за \textbf{авторизацию пользователя, ввод пароля и запуск нужного сеанса}.
	\item \textbf{Менеджер окон} - отвечает за \textbf{отрисовку окон} и управлением жизненных циклов процессов.
	\item \textbf{Приложение рабочего стола} - приложение, которое \textbf{рисует рабочий стол}
\end{itemize}

\subsection{X сервер}

\begin{Def}
	\underline{Сервер} --- это процесс, который принимает входящие подключения (от одного или нескольких клиентов) и как-то их обрабатывает.
\end{Def}

\begin{Def}
	\underline{X cервер} --- это некоторая программа, которая имеет доступ к видеокарте, клавиатуре, мыши.
\end{Def}

Когда мы запускаем некоторое графическое приложение, оно устанавливает соединение через локальный сокет с сервером DISPLAY. 

В переменной окружения DISPLAY указан адрес сервера, номер терминала (DISPLAY=:0.0 значит, что к DISPLAY можно подключиться по адресу localhost, номер терминала - 0).

Соединение можно пробросить через протокол ssh:
ssh \textbf{-X} user@hostname

\subsection{Приложения}

Приложения - это некоторый пакеты:
\begin{itemize}
	\item \textbf{обычные архивы} (FreeBSD)
	\item \textbf{RPM} (rpm to install, rpmbuild to build)
	\item \textbf{DEV} (dpkg to install, debuild to build)
\end{itemize}

Пакеты:
\begin{itemize}
	\item \textbf{Набор файлов}
	\item \textbf{Установочные} скрипты и скрипты \textbf{деинсталяции}.
	\item \textbf{Метаинформация}: название, версия, описание, \textbf{зависимости}
\end{itemize}

Пакеты зависят друг от друга:
\begin{itemize}
	\item \textbf{Библиотеки конкретных версий}
	\item Продукт может быть разбит на \textbf{несколько частей}: отдельные части под конкретные архитектуры и общие для всех архитектур.
\end{itemize}

Для того, чтобы управлять зависимостями и скачивать пакеты из удаленных репозиториев существуют \textbf{пакетные менеджеры}:
\begin{itemize}
	\item \textbf{apt-get} (apt) for Debian/Ubuntu (dpkg)
	\item \textbf{yum} (dnf) for Fedora (rpm)
	\item \textbf{apt-get} for AltLinux (rpm)
\end{itemize}

\subsection{Установка из исходного кода}

\begin{itemize}
	\item Большинство программ в Linux имеют открытый исходный код
	\item Исходный код запаковывают в архивы
	\item Исходный код требует каких-то дополнительных библиотек.
	\item Стандартный способ установки: \\
	./configure \\
	make  \\
	make install \\
\end{itemize}

Иерархия каталогов:
\begin{itemize}
	\item \textbf{Корневой каталог} / имеет bin, lib, ...
	\item \textbf{/usr} директория имеет очень похожую структуру
	\item \textbf{/usr/local содержит кастомные конфиругации.} То есть то, что не покрывается софтом, установленным из пакетов.
\end{itemize}

Такая структура имеет исторические причины. В старых UNIX-системах была привязка к железу. Обычно был один маленький, быстрый диск и другой, большой, помедленнее. Тот, что большой, помедленнее монтировался к /usr.

\textbf{Как сейчас устроено распределение?} 

\textbf{Основной каталог - /usr. }

\textbf{В корневой каталог помещается все, что востребовано в качестве минимальной системы.} То есть это минимальный набор файлов, чтобы посмотреть состояние системы, список файлов, что-то подмонтировать, ...

Хотя в некоторых дистрибутивах, например, Fedora, \textbf{/bin и /lib являются просто символическими ссылками на соответствующие разделы /usr.}

При этом если вы запускаете какую-то утилиту, то \textbf{поиск происходит от корня в глубину}. То есть сначала /bin, потом /usr/bin, а уже затем - /usr/local/bin. По этому чтобы запустить правильную версию, надо либо указать полный путь к программе, либо поменять переменную PATH.

\subsection{Makefile}

\begin{Def}
	\underline{Список целей и правил для компиляции целей} --- cписок целей и правил для компиляции целей.
\end{Def}

\subsection{Исполняемые файлы и библиотеки}

\begin{itemize}
	\item \textbf{Статические библиотеки}
		\begin{itemize}
			\item Индексированный архив обьектных файлов
			\item Сейчас редко используются
		\end{itemize}
	\item \textbf{Динамические библиотеки}
		\begin{itemize}
			\item Как обычные исполняемые файлы
			\item Нет точки входа
			\item Есть таблица символов
		\end{itemize}
\end{itemize}


\subsection{Генерация Makefile-ов}

\textbf{Зачем нужны конфигурационные скрипты?} Почему бы в поставке софта не использовать сразу готовый Makefile? Систаксис Makefile-ов может сильно отличаться. Кроме того, необходимые нам библиотеки могут располагаться в разных путях.

Решения:
\begin{itemize}
	\item \textbf{./configure script} 
		\item Требует только shell и базовые инструменты
		\item Трудно поддерживать. Solution: autotools
	\item \textbf{qmake/jam/scons/custom scripts} - обычно привязаны к конкретному фреймворку.
	\item \textbf{cmake}
\end{itemize}

\subsection{CMake}

\begin{itemize}
	\item Универсальный C и С++ инструмент для генерации:
		\begin{itemize}
			\item Makefiles
			\item Проекты для Visual Studio, XCode и CodeBlocks
		\end{itemize}
	\item Много вспомогательных модулей для пакетов с открытым исходным кодом
\end{itemize}

\subsection{Распространение софта}

\begin{itemize}
	\item Предоставить файлы для компиляции: ./configure, CMakeLists.txt, ...
	\item Предоставить ./debian/ файлы (debuild) для Ubuntu/Debian
	\item Предоставить package.spec (rpmbuild) для разных дистрибутивов
	\item \href{https://launchpad.net}{Ubuntu LaunchPad}
	\item \href{https://build.opensuse.org}{openSUSE Build Service}
\end{itemize}

